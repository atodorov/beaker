<?xml version='1.0'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>

                    <section id="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests">
                      <title>Writing and Running Multihosts Tasks</title>
                      <para>All of the examples so far have run on a single host. Beaker has support for tasks that run on multiple hosts, e.g. for testing the interactions of a client and a server. 
                        </para>
                        <para>When a multihost task is run in the lab, a machine will be allocated to each role in the test. Each machine has its own recipe. 
                        </para>
                        <para>Each machine under test will need to synchronize to ensure that they start the test together, and may need to synchronize at various stages within the test. Beaker has three notional roles: client, server and driver. 
                        </para>
                        <para>For many purposes all you will need are client and server roles. For a test involving one or more clients talking to one or more servers, a typical approach would be for the clients to block whilst the servers get ready. Once all servers are ready, the clients perform whatever testing they need, using the services provided by the server machines, and eventually report results back to the test system. Whilst this is happening the server tests block; the services running on these machines are carrying out work for the clients in parallel. Once all clients have finished testing, the server tests finish, and report their results. 
                        </para>
                        <para>Each participant in a test will be reporting results within the same job, and so must report to different places within the result hierarchy. For example, the server part of the test may PASS if it survives the load, but the client part might FAIL upon, say, getting erroneous data from the server; this would lead to an overall FAIL for the test. 
                        </para>
                        <para>If you have a more complex arrangement, it is possible to have a driver machine which controls all of the testing. 
                        </para>
                        <para>All of the participants in a multihost test share a single <application>runtest.sh</application>, which must perform every role within the test (e.g. the client role and server role). When a multihost test is run in the lab, the framework automatically sets environment variables to allow the various participants to know what their role should be, which other machines they should be talking to, and what roles those other machines are performing in the test. You will need to have logic in your<application> runtest.sh</application> to examine these variables, and perform the necessary role accordingly. These variables are shared by all instances of the runtest.sh within a recipeset:
                          <itemizedlist>
                            <listitem>
                              <para><application>CLIENTS</application> contains a space-separated list of hostnames of clients within this recipeset.  
                              </para>
                            </listitem>
                            <listitem>
                              <para><application>SERVERS</application> contains a space-separated list of hostnames of servers within this recipeset.
                              </para>
                            </listitem>
                            <listitem>
                              <para><application>DRIVER</application> is the hostname of the driver of this recipeset, if any. 
                              </para>
                            </listitem>
                          </itemizedlist>
                        </para>
                        <para>The variable HOSTNAME can be used by runtest.sh to determine its identity. It is set by beaker-environment.sh, and will be unique for each host within a recipeset. 
                        </para>
                        <para>Your test can thus decide whether it is a client, server or driver by investigating these variables: see the example below. 
                        </para>
                        <para>When you are developing your test outside the lab environment, only HOSTNAME is set for you (when sourcing the beaker-environment.sh script). Typically you will copy your test to multiple development machines, set up CLIENTS, SERVERS and DRIVER manually within a shell on each machine, and then manually run the runtest.sh on each one, debugging as necessary. 
                        </para>
                        <para>A multihost test needs to be marked as such in the<emphasis> Type: Multihost</emphasis>. 
                        </para>

                      <para> In it's simplest form, a job with multihost testing can look like:
                      </para>
                      <screen>&lt;job&gt;
  &lt;RecipeSet&gt;
     &lt;recipe&gt;
        &lt;task role='STANDALONE' name='/distribution/install'/&gt;
        &lt;task role='SERVERS' name='/my/multihost/test'/&gt;
     &lt;/recipe&gt;
     &lt;recipe&gt;
        &lt;task role='STANDALONE' name='/distribution/install'/&gt;
        &lt;task role='CLIENTS' name='/my/multihost/test'/&gt;
     &lt;/recipe&gt;
  &lt;/RecipeSet&gt;
&lt;/job&gt;</screen>
                      <note>
                        <para>For brewity some necessary parts are left out in the above job description
                        </para>
                      </note>
                      <note>
                      <title>Tips</title>
                        <para>you can use <ulink url="https://engineering.redhat.com/trac/beaker/wiki/ResultExecutingWorkflow#MultiWorkflow">multi_workflow.py</ulink> to generate a XML template </para>
                      </note>
                      <para>Submitting the job above will export environmental variables SERVERS and CLIENTS set to their respective hostnames. This allows a tester to write tests for each machines. So the runtest.sh in /my/multihost/test test might look like: </para>
                      <screen>Server() {
    # .. server code here
}

Client() {
    # .. client code here
}

if test -z "$JOBID" ; then
    echo "Variable jobid not set! Assume developer mode" 
    SERVERS="test1.example.com"
    CLIENTS="test2.example.com"
    DEVMODE=true
fi

if [ -z "$SERVERS" -o -z "$CLIENTS" ]; then
    echo "Can not determine test type! Client/Server Failed:" 
    RESULT=FAILED
    report_result $TEST $RESULT
fi

if $(echo $SERVERS | grep -q $HOSTNAME); then
    TEST="$TEST/Server"
    Server
fi

if $(echo $CLIENTS | grep -q $HOSTNAME); then
    TEST="$TEST/Client"
    Client
fi</screen>
                      <para>
                      Let's disect the code. First of, we have Server() and Client() functions which will be executed on SERVERS and CLIENTS machines respectively. Then we have an if block to determine if this is running as an beaker test, or if it's being run on the test developer's machine(s) to test it out. The last couple if blocks determine what code to run on this particular machine. As mentioned before, SERVERS and CLIENTS environmental variables will be set to their respective machines' names and exported on both machines. 
                      </para>
                      <para>
                      Obviously, there will have to be some sort of coordination and synchronization between the machines and the execution of the test code on both sides. Beaker offers two utilities for this purpose, rhts-sync-set and rhts-sync-block . rhts-sync-set is used to setting a state on a machine. rhts-sync-block is used to block the execution of the code until a certain state on certain machine(s) are reached. Those familiar with parallel programming can think of this as a barrier operation . The detailed usage information about both of this utilities is below:
                      <itemizedlist>
                        <listitem>
                          <para><application>rhts-sync-set:</application> It does set the state of the current machine. State can be anything. Syntax: rhts-sync-set -s STATE
                          </para>
                        </listitem>
                        <listitem>
                          <para><application>rhts-sync-block:</application> It blocks the code and doesn't return until a desired STATE is set on desired machine(s) . You can actually look for a certain state on multiple machines.. Syntax: rhts-sync-block -s STATE [-s STATE1 -s STATE2] machine1 machine2 ... 
                          </para>
                        </listitem>
                      </itemizedlist>
                    </para>
                    <para>There are a couple of important points to pay attention. First of, the multihost testing must be on the same chronological order on all machines. For example, the below will fail: 
                    </para>
                    <screen>
          &lt;recipe&gt;
            &lt;task role='STANDALONE' name='/distribution/install'/&gt;
            &lt;task role='STANDALONE' name='/my/test/number1'/&gt;
            &lt;task role='SERVERS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
          &lt;recipe&gt;
            &lt;task role='STANDALONE' name='/distribution/install'/&gt;
            &lt;task role='CLIENTS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
</screen>
                    <para>This will fail, because the multihost test is the 3rd test on the server side and it's the 2nd test on the client side.. To fix this, you can pad in dummy testcases on the side that has fewer testcases. There is a dummy test that lives in /distribution/utils/dummy for this purpose. So, the above can be fixed as:
                    </para>
                    <screen>
          &lt;recipe&gt;
           &lt;task role='STANDALONE' name='/distribution/install'/&gt;
           &lt;task role='STANDALONE' name='/my/test/number1'/&gt;
           &lt;task role='SERVERS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
          &lt;recipe&gt;
           &lt;task role='STANDALONE' name='/distribution/install'/&gt;
           &lt;task role='STANDALONE' name='/distribution/utils/dummy'/&gt;
           &lt;task role='CLIENTS'     name='/my/multihost/test'/&gt;
          &lt;/recipe&gt;
</screen>
                   <para>
                    One shortcoming of the rhts-sync-block utility is that it blocks forever, so if there are multiple things being done in your test between the hosts, your test will timeout without possibly a lot of code being executed. There is a utility, blockwrapper.exp which can be used to put a limit on how many second it should block. The script lives in /CoreOS/common test, so be sure to add that test before your multihost tests in your recipes. The usage is exactly same as that of rhts-sync-block with the addition of a timeout value at the end, i.e.: 
                    </para>
                    <screen>
                    blockwrapper.exp -s STATE machine N 
                    </screen>
                    <para>where N is the timeout value in seconds. If the desired state in the desired machine(s) haven't been set in N seconds, then the script will exit with a non-zero return code. In case of success it'll exit with code 0 .
                    </para>
                        <section id="User_Guide-Getting_Started-Process-Tests-Writing_and_Running_Multihosts_Tests-Synchronization_Commands">
                          <title>Synchronization Commands</title>
                            <para>Synchronization of machines within a multihost test is performed using per-host state strings managed on the Beaker server. Each machine's starting state is the empty string.
                            </para>
                            <screen>rhts-sync-set -s state 
                            </screen>
                            <para>The rhts-sync-set command sets the state of this machine within the test to the given value. 
                            </para>
                            <screen>rhts-sync-block -s state [hostnames...] 
                            </screen>
                            <para>The rhts-sync-block command blocks further execution of this instance of the script until all of the listed hosts are in the given state. 
                            </para>
                            <para>Unfortunately, there is currently no good way to run these commands in the standalone helper environment. 
                            </para>
                            <section id="User_Guide-Getting_Started-Process-Writing_and_Running_Multihosts_Tests-Synchronization_Commands-Examples_of_a_runtest_sh_for_a_multihost_test">
                              <title>Example of a runtest.sh for a multihost test</title>
                              <screen>#!/bin/sh
# Source the common test script helpers                                       
. /usr/bin/rhts_environment.sh

# Save STDOUT and STDERR, and redirect everything to a file.
exec 5>&amp;1 6>&amp;2
exec >> "${OUTPUTFILE}" 2>&amp;1

client()
{
    echo "-- wait the server to finish."
    rhts_sync_block -s "DONE" ${SERVERS}

    user="finger1"
    for i in ${SERVERS}
    do
        echo "-- finger user \"$user\" from server \"${i}\"."
        ./finger_client "${i}" "${user}"
        # It returns non-zero for failure.
        if [ $? -ne 0 ]; then
            rhts_sync_set -s "DONE"
            report_result "${TEST}" "FAIL" 0
            exit 1
        fi
    done

    echo "-- client finishes."
    rhts_sync_set -s "DONE"
    result="PASS"
}

server()
{
    # Start server and check it is up and running.
    /sbin/chkconfig finger on &amp;&amp; sleep 5
    if ! netstat -a | grep "finger" ; then
        rhts_sync_set -s "DONE"
        report_result "${TEST}" "FAIL" 0
        exit 1
    fi
    useradd finger1
    echo "-- server finishes."
    rhts_sync_set -s "DONE"
    rhts_sync_block -s "DONE" ${CLIENTS}
    result="PASS"
}

# ---------- Start Test -------------
result="FAIL"
if echo "${CLIENTS}" | grep "${HOSTNAME}" >/dev/null; then
    echo "-- run finger test as client."
    TEST=${TEST}/client
    client
fi
if echo "${SERVERS}" | grep "${HOSTNAME}" >/dev/null; then
    echo "-- run finger test as server."
    TEST=${TEST}/server
    server
fi
echo "--- end of runtest.sh."
report_result "${TEST}" "${result}" 0
exit 0</screen>
                            </section>
                            <section id="User_Guide-Getting_Started-Tests-Process-Writing_and_Running_Multihosts_Tests-Synchronization_Commands-Tuning_up_multihost_tests">
                              <title>Tuning up multihost tests</title>
                              <para>Multihost tests can be easily tuned up outside Beaker using following code snippet based on $JOBID variable (which is set when running in Beaker environment). Just log in to two machines (let's say: client.example.com and server.example.com) and add following lines at the beginning of your runtest.sh script. 
                              </para>
                              <screen># decide if we're runnig on RHTS or in developer mode
if test -z $JOBID ; then
        echo "Variable JOBID not set, assuming developer mode"
        CLIENTS="client.example.com"
        SERVERS="server.example.com"
else
        echo "Variable JOBID set, we're running on RHTS"
fi
echo "Clients: $CLIENTS"
echo "Servers: $SERVERS"</screen>
                              <para>Then you just run the script on both client and server. When scripts reach one of the synchronization commands (rhts-sync-set or rhts-sync-block) you will be asked for supplying actual state of the client/server by keyboard (usually just confirm readiness by hitting Enter). That's it! :-) 
                              </para>
                            </section>
                        </section>
                    </section>
