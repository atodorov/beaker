<?xml version='1.0'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>

                 <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow">
                      <title>Virtualization Workflow</title>
                      <para>Virtualization workflow is designed to take advantage all Beaker offers to be used for virtualization testing. The audience of this tutorial is expected to have basic familiarity with Beaker. 
                        </para>
                        <para>Virtualization testing framework in Beaker utilizes libvirt tools, particularly virt-install program to have a framework abstracted from the underlying virtualization technology of the OS. The crux of virtualization test framework is guestrecipe. Each virtual machine is defined in its own guestrecipe and guestrecipes are a part of the host's (dom0) recipe. To illustrate, let's say, we would like to create a job that will create a host and 2 guests, named guest1 and guest2 respectively. The skeleton of the recipe will look like this: 
                        </para>
                        <screen>&lt;recipe&gt;
        ...
        (dom0 test recipe)
        ...
        &lt;guestrecipe guestname=guest1 ...&gt;
          ...
          (guest1 test recipe)
          ...
        &lt;/guestrecipe&gt;
        &lt;guestrecipe guestname=guest2 ...&gt;
          ...
          (guest2 test recipe)
          ...
        &lt;/guestrecipe&gt;

     &lt;/recipe&gt;</screen>
                        <para>xml syntax workflows example can be found here: <xref linkend="User_Guide-Getting_Started-Process-Beaker_Interface-Jobs-Job_Workflow"></xref>
                        </para>
                        <para>
                        Anything that can be described inside a recipe can also be described inside a guestrecipe. This allows the testers to run any existing Beaker test inside the guest just like it'd be run inside a baremetal machine.
                        </para>
                        <para>When Beaker encounters a guestrecipe it does create an environmental variable to be passed on to virtinstall test. The tester-supplied elements of this variable all come from the guestrecipe element. Consequently, it's vital that the tester fully understand the properties of this element. guestrecipe element guestname and guestargs elements. guestname is the name of the guest you would like to give and is optional. If you omit this property then the Beaker will assign the hostname of the guest as the name of the guest. guestargs is where you define your guest. The values given here will be same as what one would pass to virt-install program with the following exceptions:
                        <itemizedlist>
                          <listitem>
                            <para> Name argument must not be passed on inside guestargs. As mentioned above, it should be passed with guestname property..
                            </para>
                          </listitem>
                          <listitem>
                            <para>
                              Other than name , -mac, -location, -cdrom (-c) , and -extra-args ks= must not be passed. Beaker does those based on distro information passed inside the guestrecipe.
                            </para>
                          </listitem>
                          <listitem>
                            <para>In addition to what can be passed to virt-install, extra arguments -lvm or -part or -kvm can also be passed to guestargs, to indicate lvm-based or partition- based guests or kvm guests (instead of xen guests).
                            </para>
                          </listitem>
                          <listitem>
                            <para>If neither one of -lvm or -part options are given, then a filebased guest will be installed. If -kvm option is not given then xen guests will be installed. See below for lvm-,partition-based guests section for more info on this topic.
                            </para>
                          </listitem>
                          <listitem>
                            <para>The virtinstall test is very forgiving for the missed arguments, it'll use some default when it can. Currently these arguments can be omitted: 
                              <itemizedlist>
                                <listitem>
                                  <para>-ram or -r , a default of 512 is used 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>1.-nographics or -vnc, if the guest is a paravirtualized guest, then -nographics option will be used, if the guest is an hvm guest, then -vnc option will be used. 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>1.-file-size or -s, a default of 10 will be used. 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>-file or -f, if the guest is a filebased guest, then the default will be /var/lib/xen/images/${guestname}.img . For lvm-based and block-device based guest, this option MUST be provided.
                                  </para>
                                </listitem>
                              </itemizedlist>
                            </para>
                          </listitem>
                        </itemizedlist>
                        </para>
                        <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow-KVM_vs_XEN_Guests">
                        <title>KVM vs XEN GUESTS</title>
                        <para>Starting with RHEL 5.4, both xen and kvm hypervisors are shipped with the distro. To handle this situation, guest install tests take an extra argument (-kvm) to identify which type of guests will be installed. By default, kernel-xen kernel is installed hence the guests are xen guests. If -kvm is given in the guestargs, then the installation program decides that kvm guests are intended to be tested, so boots into the base kernel and then installs the guests. There can only be one hypervisor at work at one moment, and hence the installation test expects them all to be either kvm or xen guest, but not a mix of both. </para>
                        </section>
                        <section>
                          <title>Making More Sense of LVM and PARTITION based Guest Installations</title>
                            <para>Installing a file-based guest is the simplest of all. A specific file can be specified in guestarg with -file or -f arguments , or can just be omitted. However, for lvm and partition based guests, the virtinstall test will have to know where to install the guests exactly, because there is no way for it to know what the partition or volume name might be. 
                            </para>
                            <para>
                            Obviously, if lvm or partition based guests are desired a custom partitioning will have to be done. Beaker allows the testers to submit a custom partition/lvm for their tests. The syntax for this below: 
                              <command>
                              &lt;partition&gt;
                                  &lt;type&gt; type &lt;/type&gt;
                                  &lt;name&gt; name &lt;/name&gt;
                                  &lt;size&gt; size in GB &lt;/size&gt;
                                  &lt;fs&gt; filesystem to format &lt;/fs&gt;
                               &lt;/partition&gt;
                              </command>
                              <itemizedlist>
                                <listitem>
                                  <para><application>type:</application> Can be either lvm or part. This is required. 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para><application>name:</application> For partitions, this will be mount point, such as /mnt/guest1 , for lvm, it'll be the name of the volume, such as myguestlvm . In the case of lvm, it'll be named /TestVolumeGroup??/myguestlvm . This is required. 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para><application>size: </application>Size of the blockdevice in Gigabytes, this is required.
                                  </para>
                                </listitem>
                                <listitem>
                                  <para><application>fs:</application> filesystem you'd like to be formatted for this partition . This is optional, if omitted, ext3 will be used. * -file or -f guestargs, whatever the name is given inside the partition block should be passed on.
                                  </para>
                                </listitem>
                              </itemizedlist>
                            </para>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow-Other_Uses_of_PARTITIONS_and_LVM_Volumes">
                          <title>Other Uses of PARTITIONS and LVM Volumes</title>
                            <para>
                            In virtualization testing, block devices can be used for other purposes than installing a guest on them. It's possible to have block devices attached to or detached from a guest. If you'd like to do this operation in your tests, you can either pass the information about the partitions you have created as environment variable to your test, or you can use the blockdevice utility, which is another test that lives in /distribution/utils/blockdevice .This testcase just creates a text file containing information about the block devices and manages them. Its commands are: 
                            </para>
                            <para><application>getdevice</application>
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: getdevice &lt;lvm|partition&gt; &lt;minimum size in GB&gt; 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: returns a free device that has enough space 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: string with device name and return code 0 on success, error string and return code 1 on failure
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para><application>freedevice </application>
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: freedevice &lt;devicename&gt; 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Descriptions: Marks the device can free so it can be reused. 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: return code zero on success or error string and return code 1 on failure. 
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para>When running blockdevice test-util, you need to provide testing an environmental variable named BLOCKDB_ARGS, telling the test what partitions/lvms you have intended to be used in test script. The format of <code>$BLOCKDB_ARGS</code> is name:type:size:fs;name:type:size:fs; for each block device. For example suppose you have these partitions in your job:
                            </para>
                            <screen>
     &lt;partition&gt;
        &lt;type&gt;part&lt;/type&gt;
        &lt;name&gt;/mnt/block1&lt;/name&gt;
        &lt;size&gt;1&lt;/size&gt; &lt;!-- 1 gig --&gt;
     &lt;/partition&gt;
    &lt;partition&gt;
        &lt;type&gt;lvm&lt;/type&gt;
        &lt;name&gt;mylvm&lt;/name&gt;
        &lt;size&gt;5&lt;/size&gt;
     &lt;/partition&gt;
    &lt;partition&gt;
        &lt;type&gt;part&lt;/type&gt;
        &lt;name&gt;/mnt/block4ext4&lt;/name&gt;
        &lt;size&gt;1&lt;/size&gt; &lt;!-- 1 gig --&gt;
        &lt;fs&gt;ext4dev&lt;/fs&gt;
     &lt;/partition&gt;
    &lt;partition&gt;
        &lt;type&gt;lvm&lt;/type&gt;
        &lt;name&gt;mylvm4ext4&lt;/name&gt;
        &lt;size&gt;5&lt;/size&gt;
        &lt;fs&gt;ext4dev&lt;/fs&gt;
     &lt;/partition&gt;</screen>
                            <para>then BLOCKDB_ARGS would be: /mnt/block1:part:1;mylvm:lvm:5;/mnt/block4ext4:part:1:ext4dev;mylvm4ext4:lvm:5:ext4dev</para>
                            <para>If you utilize blockdevices test, you should ensure that: 
                              <itemizedlist>
                                <listitem>
                                  <para>blockdevice is called before any of your scripts 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>freedevice must be called after the testing on the space is done. 
                                  </para>
                                </listitem>
                              </itemizedlist>
                            </para>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow-Dynamic_Partitioning-IVM">
                        <title>Dynamic Partitioning/IVM</title>
                        <formalpara>
                        <title>Telling Beaker to create partitions/lvm</title>
                        <para>On Beaker, each machine has its own kickstart for each OS family it supports. In it the partitioning area is marked so that it can be overwritten to allow having dynamic partitions/lvms in your tests.</para>
                        </formalpara>
                        <para>The easiest way to specify dynamic partitions is to use the xml workflow and specify it in your xml file. Syntax of the partition tags is below: </para>
                        <screen>&lt;partition&gt;
  &lt;type&gt; type &lt;/type&gt;             &lt;!- required -&gt;
  &lt;name&gt; name &lt;/name&gt;             &lt;!- required -&gt;
  &lt;size&gt; size in GB &lt;/size&gt;       &lt;!- required -&gt;
  &lt;fs&gt; filesystem to format &lt;/fs&gt; &lt;!- optional, defaulted to ext3 -&gt;
&lt;/partition&gt;
                            </screen>
                            <para>&lt;partition&gt; is the xml element for the partitioning. You can have multiple partition elements in a recipe. It has type, name, size and fs text contents all of which except for fs is required. Detailed information for each are:
                            <itemizedlist>
                              <listitem>
                                <para><application>type:</application> Type of partition you'd like to use. This can be either part of lvm . 
                                </para>
                              </listitem>
                              <listitem>
                                <para><application>name:</application> If the type is part, then this will be the mount point of the partition. For example, if you would like the partition to be mounted to /mnt/temppartition then just put it in here. For the lvm type, this will be the name of the volume and all custom volumes will go under its own group, prefixed with TestVolumeGroup? . For example, if you name your lvm type as "mytestvolume", it's go into /TestVolumeGroup??/mytestvolume. 
                                </para>
                              </listitem>
                              <listitem>
                                <para><application>size:</application> The size of the partition or volume in GBs .
                                </para>
                              </listitem>
                              <listitem>
                                <para><application>fs:</application>This will be the filesystem the partition will be formatted in. If omitted, the partition will be formatted with ext3. By default, anaconda mounts all partitions. If you need the partition to be unmounted at the time of the test, you can use the blockdevice utility which is a test that lives on /distribution/utils/blockdevice . This test unmounts the specified partitions/volumes and lets users manage custom partitions thru its own scripts. 
                                </para>
                              </listitem>
                              <listitem>
                                <para>
                                <application>getdevice</application>
                                  <itemizedlist>
                                    <listitem>
                                      <para>Usage: getdevice &lt;lvm|partition&gt; &lt;minimum size in GB>&gt; 
                                      </para>
                                    </listitem>
                                    <listitem>
                                      <para>Description: returns a free device that has enough space 
                                      </para>
                                    </listitem>
                                    <listitem>
                                      <para>Returns: string with device name and return code 0 on success, error string 
                                      </para>
                                    </listitem>
                                    <listitem>
                                      <para>and return code 1 on failure
                                      </para>
                                    </listitem>
                                  </itemizedlist>
                                </para>
                              </listitem>
                              <listitem>
                                <para>
                                <application>freedevice</application>
                                  <itemizedlist>
                                    <listitem>
                                      <para>Usage: freedevice &lt;devicename&gt;
                                      </para>
                                    </listitem>
                                    <listitem>
                                      <para>Descriptions: Marks the device can free so it can be reused. 
                                      </para>
                                    </listitem>
                                    <listitem>
                                      <para>Returns: return code zero on success or error string and return code 1 on failure.
                                      </para>
                                    </listitem>
                                  </itemizedlist>
                                </para>
                              </listitem>
                            </itemizedlist> 
                            </para>
                            <para>When running blockdevice test-util, you need to provide testing an environmental variable named BLOCKDB_ARGS, telling the test what partitions/lvms you have intended to be used in test script. The format of $BLOCKDB_ARGS is name,type,size;name,type,size; for each block device. For example suppose you have these partitions in your job: 
                            </para>
                            <screen>
     &lt;partition&gt;
        &lt;type&gt;part&lt;/type&gt;
        &lt;name&gt;/mnt/block1&lt;/name&gt;
        &lt;size&gt;1&lt;/size&gt; &lt;!-- 1 gig --&gt;
     &lt;/partition&gt;
    &lt;partition&gt;
        &lt;type&gt;lvm&lt;/type&gt;
        &lt;name&gt;mylvm&lt;/name&gt;
        &lt;size&gt;5&lt;/size&gt;
     &lt;/partition&gt;
    &lt;partition&gt;
        &lt;type&gt;part&lt;/type&gt;
        &lt;name&gt;/mnt/block4ext4&lt;/name&gt;
        &lt;size&gt;1&lt;/size&gt; &lt;!-- 1 gig --&gt;
        &lt;fs&gt;ext4dev&lt;/fs&gt;
     &lt;/partition&gt;
    &lt;partition&gt;
        &lt;type&gt;lvm&lt;/type&gt;
        &lt;name&gt;mylvm4ext4&lt;/name&gt;
        &lt;size&gt;5&lt;/size&gt;
        &lt;fs&gt;ext4dev&lt;/fs&gt;
     &lt;/partition&gt;</screen>
                            <para>as in:
                            </para>
                            <screen>
&lt;test role='STANDALONE' name='/distribution/utils/blockdevice'&gt;
    &lt;params&gt;
     &lt;param name='BLOCKDB_ARGS' value='/mnt/block1:part:1;mylvm:lvm:5;/mnt/block4ext4:part:1:ext4dev;mylvm4ext4:lvm:5:ext4dev'/&gt;
    &lt;/params&gt;
&lt;/test&gt;
</screen>
                            <para>If you utilize blockdevices test, you should ensure that: 
                              <itemizedlist>
                                <listitem>
                                  <para>blockdevice is called before any of your scripts 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>freedevice must be called after the testing on the space is done. 
                                  </para>
                                </listitem>
                              </itemizedlist>
                            </para>
                        <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow-Dynamic_Partitioning-IVM-Dynamic_Partitioning_from_Your_Workflow">
                        <title>Dynamic Partitioning from Your Workflow </title>
                          <para>If you are using a different workflow and would like to add dynamic partitioning capability, you can do it by utilizing kickPart() call to the recipe object. The string you have to pass is exactly same format as the BLOCKDB_ARGS argument mentioned above. An example can be :    </para>
                          <screen>part_str = "/mnt/block1:part:1;mylvm:lvm:5;/mnt/block4ext4:part:1:ext4dev;mylvm4ext4:lvm:5:ext4dev"
     rec = Recipe(scheduler=rhts_sched)
     rec.kickPart(part_str)</screen>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow-Dynamic_Partitioning-IVM-Installing_Packages_with_Workflows">
                          <title>Installing Package with Workflows</title>
                          <para><application>Workflow</application> scripts are packaged in the beaker-redhat package.
                            <itemizedlist>
                              <listitem>
                                <para><ulink url="https://engineering.redhat.com/trac/beaker/wiki/ResultIntroduction#install">Installing package with workflows </ulink>
                                </para>
                              </listitem>
                              <listitem>
                                <para><ulink url="https://engineering.redhat.com/trac/beaker/wiki/ResultExecutingWorkflow">Executing a Workflow </ulink>
                                </para>
                              </listitem>
                          </itemizedlist>
                           </para>
                        </section>
                        </section>
                        <section id="User_Guide-Getting_Started-Process-Workflow-Virtualization_Workflow-Helper_Programs_Installed_with_Virtinstall">
                          <title>Helper Programs Installed with Virtinstall</title>
                          <para>Virtinstall test also installs a few scripts that can later on be utilized in the tests. These are completely non-vital scripts, provided only for convenience to the testers. 
                          </para>
                            <para><application>guestcheck4up</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: guestcheck4up &lt;guestname&gt; 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: checks whether or not the guest is live or not.  
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: 0 if guest is not shutoff, 1 if it is.
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para><application>guestcheck4down</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: guestcheck4down &lt;guestname&gt; 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: checks whether or not the guest is live or not.
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: 0 if guest is shutoff, 1 if it is not.  
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para><application>startguest</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: startguest &lt;guestname&gt; [timeout] 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: Starts a guest and makes sure that it's console is reachable within optional $timeout seconds. If timeout value is omitted the default is 300 seconds.
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: 0 if the guest is started and a connection can be made to its console within $timeout seconds, 1 if it can't.
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para><application>stopguest</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: stopguest &lt;guestname&gt; [timeout] 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: stops a guests and waits for shutdown by waiting for the "System Halted." string within the optional $timeout seconds. If timeout is omitted , then the default is 300 seconds. 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: 0 if the shutdown was successful, 1 if it wasn't.
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para><application>getguesthostname</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: getguesthostname &lt;guestname&gt; 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: A string that contains the hostname of the guest if successful, or an error string if it's an error.
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                            <para><application>wait4login</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: wait4login &lt;guestname&gt; [timeout] 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: It waits until it gets login: prompt in the guest's console within $timeout seconds. If timeout argument is not given, it'll wait indefinitely, unless there is an error! 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: 0 on success , or 1 if it encounters an error.
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                             <para><application>fwait4shutdown</application>:
                              <itemizedlist>
                                <listitem>
                                  <para>Usage: wait4shutdown &lt;guestname&gt; [timeout] 
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Description: It waits until it gets shutdown message in the guest's console within $timeout seconds. If timeout argument is not given, it'll wait indefinitely, unless there is an error!
                                  </para>
                                </listitem>
                                <listitem>
                                  <para>Returns: 0 on success , or 1 if it encounters an error. 
                                  </para>
                                </listitem>
                             </itemizedlist>
                            </para>
                        </section>
                      </section>
